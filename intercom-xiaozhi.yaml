# ==============================================================================
# ESP32-S3 INTERCOM XIAOZHI - Broker-based with Display
# ==============================================================================
#
# Xiaozhi Ball V3 device with ES8311 codec, GC9A01A round display, and WS2812 LED.
# Uses intercom_api component with HA Broker for ESP↔ESP communication.
# Clean YAML syntax with native platform entities.
#
# HARDWARE:
#   - Board: ESP32-S3 DevKitC-1 (16MB Flash, Octal PSRAM)
#   - Audio: ES8311 codec (I2C control + single I2S bus for duplex)
#   - Display: GC9A01A 240x240 round LCD (SPI)
#   - LED: WS2812 RGB (GPIO48)
#   - Button: GPIO0 (short press = call, long press = next contact)
#   - Speaker Amp Enable: GPIO46
#
# ==============================================================================

substitutions:
  name: intercom-xiaozhi
  friendly_name: Intercom Xiaozhi

esphome:
  name: ${name}
  friendly_name: ${friendly_name}
  min_version: 2024.12.0
  on_boot:
    priority: 600
    then:
      - light.turn_on:
          id: backlight
          brightness: 100%
      - light.turn_off: status_led
      - delay: 1s
      # Restore ES8311 volume and sync AEC reference
      - lambda: |-
          float vol = 0.15 + (id(speaker_volume).state / 100.0) * 0.60;
          id(es8311_dac).set_volume(vol);
          // AEC reference must match ES8311 hardware output level
          id(i2s_duplex).set_aec_reference_volume(vol);
          id(peer_name) = id(intercom).get_current_destination();
      - script.execute: update_display_page

esp32:
  board: esp32-s3-devkitc-1
  flash_size: 16MB
  framework:
    type: esp-idf
    sdkconfig_options:
      CONFIG_ESP32S3_DEFAULT_CPU_FREQ_240: "y"
      CONFIG_ESP32S3_DATA_CACHE_64KB: "y"
      CONFIG_ESP32S3_DATA_CACHE_LINE_64B: "y"
      # Default is 10, increased for: TCP server + API + OTA + web_server
      CONFIG_LWIP_MAX_SOCKETS: "16"
    components:
      # Required for AEC (esp_aec component)
      - espressif/esp-sr^2.3.0

psram:
  mode: octal   # Xiaozhi has octal PSRAM (faster than quad)
  speed: 80MHz

# ==============================================================================
# CONNECTIVITY
# ==============================================================================
api:
  on_client_connected:
    - lambda: |-
        // Only publish once on first HA connection (not on every log viewer connect)
        static bool published = false;
        if (!published) {
          published = true;
          id(intercom).publish_entity_states();
        }

ota:
  - platform: esphome

web_server:
  port: 80

logger:
  hardware_uart: USB_SERIAL_JTAG
  level: INFO
  logs:
    intercom_api: INFO
    i2s_duplex: INFO
    component: INFO

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  ap:
    ssid: "${name} Fallback"

# ==============================================================================
# EXTERNAL COMPONENTS
# ==============================================================================
external_components:
  - source:
      type: local
      path: esphome_components
    components: [intercom_api, i2s_audio_duplex, esp_aec]

# ==============================================================================
# I2C BUS (for ES8311 codec control)
# ==============================================================================
i2c:
  sda: GPIO15
  scl: GPIO14
  scan: false

# ==============================================================================
# AUDIO CODEC (ES8311)
# ==============================================================================
audio_dac:
  - platform: es8311
    id: es8311_dac
    bits_per_sample: 16bit
    sample_rate: 16000

# ==============================================================================
# ECHO CANCELLATION
# ==============================================================================
esp_aec:
  id: aec_component
  sample_rate: 16000
  filter_length: 8     # 8 = 128ms tail (max value, covers most latency scenarios)
  mode: voip_high_perf # High performance AEC for better echo cancellation

# ==============================================================================
# I2S AUDIO DUPLEX (single bus for ES8311)
# ==============================================================================
i2s_audio_duplex:
  id: i2s_duplex
  i2s_lrclk_pin: GPIO45
  i2s_bclk_pin: GPIO9
  i2s_mclk_pin: GPIO16
  i2s_din_pin: GPIO10
  i2s_dout_pin: GPIO8
  sample_rate: 16000
  aec_id: aec_component   # AEC here for perfect mic/speaker sync (same audio task)
  aec_reference_delay_ms: 10  # ES8311 integrated codec - minimal acoustic delay
  mic_attenuation: 0.1       # -20dB: ES8311 ADC is very hot, attenuate BEFORE AEC to prevent clipping

# ==============================================================================
# MICROPHONE (via duplex platform)
# ==============================================================================
microphone:
  - platform: i2s_audio_duplex
    id: mic_component
    i2s_audio_duplex_id: i2s_duplex

# ==============================================================================
# SPEAKER (via duplex platform)
# ==============================================================================
speaker:
  - platform: i2s_audio_duplex
    id: spk_component
    i2s_audio_duplex_id: i2s_duplex

# Speaker amplifier enable pin
output:
  - platform: gpio
    id: speaker_enable
    pin: GPIO46
  - platform: ledc
    id: backlight_output
    pin: GPIO42
    inverted: true

# ==============================================================================
# INTERCOM API (TCP-based, port 6054)
# ==============================================================================
# Auto-creates these sensors:
#   - text_sensor: intercom_state (Idle/Ringing/Streaming)
#   - text_sensor: destination (selected contact) [full mode only]
#   - text_sensor: caller (who is calling) [full mode only]
#   - text_sensor: contacts (count) [full mode only]

intercom_api:
  id: intercom
  mode: full              # full = ESP↔ESP calls with contacts, simple = browser only
  microphone: mic_component
  speaker: spk_component
  # NOTE: AEC is handled by i2s_audio_duplex for better timing (same audio task)
  ringing_timeout: 30s    # Auto-decline unanswered calls

  # === New FSM triggers for clean page switching ===
  on_incoming_call:
    - lambda: 'id(peer_name) = id(intercom).get_caller();'
    - display.page.show: page_ringing_in
    - component.update: main_display

  on_outgoing_call:
    - lambda: 'id(peer_name) = id(intercom).get_current_destination();'
    - light.turn_on:
        id: status_led
        effect: "Calling"
    - display.page.show: page_ringing_out
    - component.update: main_display
    # Doorbell event for "Home Assistant" destination (for HA automations/notifications)
    # ESP-to-ESP bridge is handled automatically by HA detecting state change to "Outgoing"
    - if:
        condition:
          lambda: 'return id(intercom).get_current_destination() == "Home Assistant";'
        then:
          - homeassistant.event:
              event: esphome.intercom_call
              data:
                caller: !lambda 'return App.get_friendly_name();'
                destination: "Home Assistant"
                type: "doorbell"

  on_ringing:
    - light.turn_on:
        id: status_led
        effect: "Ringing"

  on_answered:
    - logger.log: "Call answered"

  on_streaming:
    - light.turn_on:
        id: status_led
        red: 30%
        green: 69%
        blue: 31%
        effect: none
    - output.turn_on: speaker_enable
    - display.page.show: page_in_call
    - component.update: main_display

  on_idle:
    - light.turn_off: status_led
    - output.turn_off: speaker_enable
    - lambda: 'id(peer_name) = id(intercom).get_current_destination();'
    - display.page.show: page_idle
    - component.update: main_display

  on_hangup:
    - logger.log:
        format: "Hangup: %s"
        args: ['reason.c_str()']

  on_call_failed:
    - logger.log:
        format: "Call failed: %s"
        args: ['reason.c_str()']

# ==============================================================================
# GLOBALS (only peer_name for display)
# ==============================================================================
globals:
  - id: peer_name
    type: std::string
    restore_value: no
    initial_value: '"Home Assistant"'

# ==============================================================================
# SCRIPTS (only display update)
# ==============================================================================
script:
  - id: update_display_page
    mode: restart
    then:
      - if:
          condition:
            intercom_api.is_idle:
              id: intercom
          then:
            - display.page.show: page_idle
          else:
            - if:
                condition:
                  intercom_api.is_incoming:
                    id: intercom
                then:
                  - display.page.show: page_ringing_in
                else:
                  - if:
                      condition:
                        intercom_api.is_calling:
                          id: intercom
                      then:
                        - display.page.show: page_ringing_out
                      else:
                        - if:
                            condition:
                              intercom_api.is_in_call:
                                id: intercom
                            then:
                              - display.page.show: page_in_call
      - component.update: main_display

# ==============================================================================
# DISPLAY UPDATE INTERVAL - DISABLED to prevent SPI race condition
# Display is updated via update_display_page script on state changes
# ==============================================================================
# interval:
#   - interval: 1s
#     then:
#       - component.update: main_display

# ==============================================================================
# BUTTONS (all template - no hardcoded platform)
# ==============================================================================
button:
  # Smart Call button: idle→call, ringing→answer, streaming→hangup
  - platform: template
    id: call_button
    name: "Call"
    icon: "mdi:phone"
    on_press:
      - intercom_api.call_toggle:
          id: intercom

  # Next contact (full mode)
  - platform: template
    id: next_contact_button
    name: "Next Contact"
    icon: "mdi:arrow-right"
    on_press:
      - intercom_api.next_contact:
          id: intercom
      - lambda: 'id(peer_name) = id(intercom).get_current_destination();'
      - script.execute: update_display_page

  # Previous contact (full mode)
  - platform: template
    id: prev_contact_button
    name: "Previous Contact"
    icon: "mdi:arrow-left"
    on_press:
      - intercom_api.prev_contact:
          id: intercom
      - lambda: 'id(peer_name) = id(intercom).get_current_destination();'
      - script.execute: update_display_page

  # Decline incoming call
  - platform: template
    id: decline_button
    name: "Decline"
    icon: "mdi:phone-hangup"
    on_press:
      - intercom_api.decline_call:
          id: intercom

  # Refresh contacts from HA
  - platform: template
    id: refresh_contacts_button
    name: "Refresh Contacts"
    icon: "mdi:refresh"
    entity_category: config
    on_press:
      - intercom_api.set_contacts:
          id: intercom
          contacts_csv: !lambda 'return id(ha_active_devices).state;'
      - lambda: 'id(peer_name) = id(intercom).get_current_destination();'
      - script.execute: update_display_page

  - platform: restart
    name: "Restart"
    icon: "mdi:restart"

# ==============================================================================
# SWITCHES (native platform)
# ==============================================================================
switch:
  - platform: intercom_api
    intercom_api_id: intercom
    auto_answer:
      id: auto_answer_switch
      name: "Auto Answer"
      restore_mode: RESTORE_DEFAULT_OFF

  - platform: i2s_audio_duplex
    i2s_audio_duplex_id: i2s_duplex
    aec:
      id: aec_switch
      name: "Echo Cancellation"
      restore_mode: RESTORE_DEFAULT_ON

# ==============================================================================
# NUMBERS (native platform - mic_gain only, speaker uses ES8311)
# ==============================================================================
number:
  - platform: intercom_api
    intercom_api_id: intercom
    mic_gain:
      id: mic_gain
      name: "Mic Gain"

  # Speaker volume with ES8311 hardware control (different from intercom_api volume)
  # IMPORTANT: Also sync to i2s_duplex for AEC reference scaling
  - platform: template
    id: speaker_volume
    name: "Speaker Volume"
    icon: "mdi:volume-high"
    min_value: 0
    max_value: 100
    step: 5
    initial_value: 50
    optimistic: true
    restore_value: true
    unit_of_measurement: "%"
    set_action:
      - lambda: |-
          // ES8311 volume range: 0.15 (min) to 0.75 (max)
          float es8311_vol = 0.15 + (x / 100.0) * 0.60;
          id(es8311_dac).set_volume(es8311_vol);
          // AEC reference must match ES8311 hardware output level
          // This ensures reference amplitude matches actual echo picked up by mic
          id(i2s_duplex).set_aec_reference_volume(es8311_vol);

# ==============================================================================
# TEXT SENSORS
# ==============================================================================
text_sensor:
  - platform: homeassistant
    id: ha_active_devices
    entity_id: sensor.intercom_active_devices
    on_value:
      - intercom_api.set_contacts:
          id: intercom
          contacts_csv: !lambda 'return x;'
      - lambda: 'id(peer_name) = id(intercom).get_current_destination();'
      - script.execute: update_display_page

# ==============================================================================
# BINARY SENSORS
# ==============================================================================
binary_sensor:
  - platform: status
    id: node_status
    name: "Status"

  # Main button using on_multi_click for proper single/double/triple detection
  #   - Single click: call/answer/hangup (smart button)
  #   - Double click: next contact (if idle) or decline (if ringing)
  #   - Triple click: refresh contacts
  - platform: gpio
    pin:
      number: GPIO0
      mode: INPUT_PULLUP
      inverted: true
    id: main_button
    name: "Main Button"
    icon: "mdi:gesture-tap-button"
    filters:
      - delayed_on: 20ms
      - delayed_off: 20ms
    on_multi_click:
      # Single click: call/answer/hangup
      - timing:
          - ON for 50ms to 500ms
          - OFF for at least 400ms
        then:
          - button.press: call_button
      # Double click: next contact or decline
      - timing:
          - ON for 50ms to 500ms
          - OFF for 50ms to 400ms
          - ON for 50ms to 500ms
          - OFF for at least 400ms
        then:
          - if:
              condition:
                intercom_api.is_ringing:
                  id: intercom
              then:
                - button.press: decline_button
              else:
                - if:
                    condition:
                      intercom_api.is_idle:
                        id: intercom
                    then:
                      - button.press: next_contact_button
      # Triple click: refresh contacts
      - timing:
          - ON for 50ms to 500ms
          - OFF for 50ms to 400ms
          - ON for 50ms to 500ms
          - OFF for 50ms to 400ms
          - ON for 50ms to 500ms
        then:
          - button.press: refresh_contacts_button

  - platform: gpio
    pin:
      number: GPIO12
      mode: INPUT_PULLUP
      inverted: true
    id: touch_input
    name: "Display Touch"
    icon: "mdi:gesture-tap"

# ==============================================================================
# SENSORS
# ==============================================================================
sensor:
  - platform: wifi_signal
    id: wifi_signal_db
    name: "WiFi Signal dBm"
    icon: "mdi:wifi"
    update_interval: 30s

  - platform: template
    id: wifi_pct
    name: "WiFi Signal %"
    icon: "mdi:wifi"
    unit_of_measurement: "%"
    update_interval: 30s
    lambda: |-
      if (!id(wifi_signal_db).has_state()) return 0.0f;
      float dbm = id(wifi_signal_db).state;
      if (dbm >= -50) return 100.0f;
      if (dbm <= -100) return 0.0f;
      return 2.0f * (dbm + 100.0f);

  - platform: uptime
    name: "Uptime"
    update_interval: 60s

  - platform: internal_temperature
    name: "CPU Temperature"
    update_interval: 60s

# ==============================================================================
# DISPLAY BACKLIGHT
# ==============================================================================
light:
  - platform: monochromatic
    id: backlight
    name: "Display Backlight"
    icon: "mdi:brightness-6"
    output: backlight_output
    restore_mode: ALWAYS_ON
    default_transition_length: 250ms

# ==============================================================================
# STATUS LED (WS2812 RGB on GPIO48)
# ==============================================================================
  - platform: esp32_rmt_led_strip
    id: status_led
    name: "Status LED"
    icon: "mdi:led-on"
    pin: GPIO48
    chipset: WS2812
    num_leds: 1
    rgb_order: grb
    effects:
      - strobe:
          name: "Ringing"
          colors:
            - state: true
              brightness: 100%
              red: 100%
              green: 0%
              blue: 0%
              duration: 300ms
            - state: false
              duration: 300ms
      - strobe:
          name: "Calling"
          colors:
            - state: true
              brightness: 100%
              red: 100%
              green: 50%
              blue: 0%
              duration: 500ms
            - state: false
              duration: 500ms

# ==============================================================================
# FONTS (for display)
# ==============================================================================
font:
  - file:
      type: gfonts
      family: Roboto
      weight: 700
    id: font_title
    size: 24
  - file:
      type: gfonts
      family: Roboto
      weight: 500
    id: font_state
    size: 28
  - file:
      type: gfonts
      family: Roboto
      weight: 400
    id: font_info
    size: 20
  - file:
      type: gfonts
      family: Roboto Mono
      weight: 400
    id: font_debug
    size: 14

# ==============================================================================
# COLORS (for display)
# ==============================================================================
color:
  - id: color_white
    red: 100%
    green: 100%
    blue: 100%
  - id: color_black
    red: 0%
    green: 0%
    blue: 0%
  - id: color_red
    red: 100%
    green: 0%
    blue: 0%
  - id: color_green
    red: 0%
    green: 100%
    blue: 0%
  - id: color_blue
    red: 0%
    green: 0%
    blue: 100%
  - id: color_yellow
    red: 100%
    green: 100%
    blue: 0%
  - id: color_orange
    red: 100%
    green: 60%
    blue: 0%

# ==============================================================================
# DISPLAY (GC9A01A 240x240 Round LCD)
# ==============================================================================
spi:
  - id: spi_bus
    clk_pin: GPIO4
    mosi_pin: GPIO2

display:
  - platform: ili9xxx
    id: main_display
    model: GC9A01A
    invert_colors: true
    data_rate: 40MHz
    cs_pin: GPIO5
    dc_pin: GPIO47
    reset_pin: GPIO38
    update_interval: never
    dimensions:
      height: 240
      width: 240
    pages:
      # PAGE: IDLE
      - id: page_idle
        lambda: |-
          constexpr int cx = 120;
          constexpr int h = 240;
          it.fill(id(color_blue));
          it.print(cx, 30, id(font_title), id(color_white), TextAlign::CENTER, "${friendly_name}");
          it.print(cx, 70, id(font_debug), id(color_white), TextAlign::CENTER, "Status:");
          it.print(cx, 100, id(font_state), id(color_green), TextAlign::CENTER, "IDLE");
          it.print(cx, 130, id(font_debug), id(color_white), TextAlign::CENTER, "Destination:");
          it.print(cx, 150, id(font_info), id(color_white), TextAlign::CENTER, id(peer_name).c_str());
          char buf[32];
          snprintf(buf, sizeof(buf), "WiFi: %.0f%%", id(wifi_pct).state);
          it.print(cx, h - 35, id(font_debug), id(color_white), TextAlign::CENTER, buf);
          it.print(cx, h - 15, id(font_debug), id(color_white), TextAlign::CENTER,
                   id(node_status).state ? "HA: OK" : "HA: --");

      # PAGE: RINGING_IN
      - id: page_ringing_in
        lambda: |-
          constexpr int cx = 120;
          it.fill(id(color_red));
          it.print(cx, 30, id(font_title), id(color_white), TextAlign::CENTER, "${friendly_name}");
          it.print(cx, 70, id(font_debug), id(color_white), TextAlign::CENTER, "Status:");
          it.print(cx, 100, id(font_state), id(color_yellow), TextAlign::CENTER, "RINGING");
          it.print(cx, 130, id(font_debug), id(color_white), TextAlign::CENTER, "Incoming call from:");
          it.print(cx, 160, id(font_info), id(color_white), TextAlign::CENTER, id(peer_name).c_str());
          it.print(cx, 200, id(font_debug), id(color_yellow), TextAlign::CENTER, "Press button to answer");

      # PAGE: RINGING_OUT
      - id: page_ringing_out
        lambda: |-
          constexpr int cx = 120;
          it.fill(id(color_orange));
          it.print(cx, 30, id(font_title), id(color_white), TextAlign::CENTER, "${friendly_name}");
          it.print(cx, 70, id(font_debug), id(color_white), TextAlign::CENTER, "Status:");
          it.print(cx, 100, id(font_state), id(color_black), TextAlign::CENTER, "CALLING");
          it.print(cx, 130, id(font_debug), id(color_white), TextAlign::CENTER, "Calling:");
          it.print(cx, 160, id(font_info), id(color_white), TextAlign::CENTER, id(peer_name).c_str());
          it.print(cx, 200, id(font_debug), id(color_white), TextAlign::CENTER, "Waiting for answer...");

      # PAGE: IN_CALL
      - id: page_in_call
        lambda: |-
          constexpr int cx = 120;
          constexpr int h = 240;
          it.fill(id(color_green));
          it.print(cx, 30, id(font_title), id(color_white), TextAlign::CENTER, "${friendly_name}");
          it.print(cx, 70, id(font_debug), id(color_white), TextAlign::CENTER, "Status:");
          it.print(cx, 100, id(font_state), id(color_blue), TextAlign::CENTER, "IN CALL");
          it.print(cx, 130, id(font_debug), id(color_white), TextAlign::CENTER, "Connected to:");
          it.print(cx, 150, id(font_info), id(color_white), TextAlign::CENTER, id(peer_name).c_str());
          it.print(cx, h - 15, id(font_debug), id(color_white), TextAlign::CENTER, "Press button to hang up");
